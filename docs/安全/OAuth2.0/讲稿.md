这个世界上什么最贵？



1、oauth和security属于哪个技术层面的事情，为什么会出现这个俩哥们

课题太大，能讲多少讲多少。

讲security 不讲oauth，就有点耍流氓了。

oauth，现在大家看到的都是oauth2 ，为什么叫2，因为她真的有两套，我们这里主要讲oauth2，想了解oauth1的，出门右拐。

oauth1和oauth2的最大区别，就是流程的改进，变得更全面，更安全，当然也更啰嗦。这个我们后面讲oauth2的授权模式的就能体会了。

至于spring security是什么？

​	1、来自大佬，功能强大，spring 默认组件

​	2、开箱即用，在项目里面，你只是加一个security依赖，就给你实现一套完整的安全拦截。

![image-20201026114632019](讲稿.assets/image-20201026114632019.png)

![image-20201026114644161](讲稿.assets/image-20201026114644161.png)

1、会话管理的前世今生--引出token及跨域

cookie、session、token

同源策略与跨域 ，csrf攻击

单点登陆：CAS、oauth、openID

jwt

sso引出oauth和openId

结论：一切为了安全



2、讲oauth的理论模型-参考极客时间，王新栋老师的《oauth2.0 实战课》

基础概念：

认证：证明你是你

授权：许可证，有权限的第三方可以访问自身的资源。

oauth的定位就是授权协议，所以，一般小厂不用，也没必要。目前使用oauth2对外提供授权服务的，要不就是你的用户群很庞大，比较微信/新浪，要不就是做平台的，且有较大的业务量。

说白一点：就是你有被很多别人利用的价值了，你用oauth才比较合适。

场景引入oauth2：

我们公司现在的框架就是oauth和security都用了。主要处理授权和单点登录的问题。

以电商为例，加入你是一个卖家（小明），你在京东商城开了一家店铺，平时你要将收到的订单打印出来以便仓库给用户发货，这实在太过于繁琐。后来啊，京东就搞了一个开放平台，市面上就有人意识到商机来了，就搞了个专门帮人打单的软件，专门帮商家处理打单这事。

问题：那既然打单软件要帮你处理订单打印，那他肯定得可以访问京东开放平台，去拿到你的订单数据吧

这种情况最简单的就是小明把自己的账号密码告诉打单软件，打单软件就可以基于小明的身份去京东开发平台登录，然后操作了。

但方案靠谱吗？安全吗？

显然不是我们想要的，更完善的思路应该是你先在京东开放平台上给打单软件授权，明确告诉京东开发平台打单软件能做什么，时候时候能做等等。这样，打单软件后面才能拿着你的授权去访问京东开放平台，获取你的订单数据，然后帮你处理打单事情。

这么一套授权机制，后面被抽象成oauth2.0。

所以，oauth2.0的定位是有一种授权协议，保证第三方只有获得授权后，才可以进一步操作授权者的数据。换一种说法，也可以叫他安全协议。



我们通过下面流程图来详细认识一下整个授权流程：

![image-20201026162219595](讲稿.assets/image-20201026162219595.png)

问题：

两次重定向，是不是很累，为什么需要第一次重定向，而不可以直接去掉，只保留第二次重定向，由授权服务器直接生成token之后返回打单软件，然后打单软件就可以使用这个access_token访问京东开放平台了。

听上去很完美：

![image-20201026162304878](讲稿.assets/image-20201026162304878.png)

去掉之后两种方案：

1、直接返回打单软件浏览器？

![image-20201026162339903](讲稿.assets/image-20201026162339903.png)

当然不行，因为<font style='color:red'>**这样会把安全保密性极高的访问令牌暴露在浏览器上**。</font>

1、直接返回打单软件后台？

![image-20201026162412180](讲稿.assets/image-20201026162412180.png)

导致问题：当小明第一次被重定向到授权服务上授权的时候，小明和打单软件之间的“连接”断了。相当于界面将一直停留在授权服务的页面上。

**结论：为了让小明和打单软件重新建立连接，又不能让访问令牌暴露在浏览器上面，就有了这样一个临时/间接的凭证：授权码**

TODO：要不要补充间接和直接引用

上面的流程，涉及到四个角色：资源拥有者(小明)、第三方软件（打单软件）、授权服务、受保护资源（订单数据）

他们是两两分组的：

![image-20201026163414465](讲稿.assets/image-20201026163414465.png)

实际上刚刚的这个授权流程，他有一个比较正式的名字：授权码模式。

这种模式也是oauth协议里面最安全的一种了，也被借鉴到很多其他场景，比如微信公众号、小程序等。

微信官方文档：https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/login/auth.code2Session.html

![image-20201026164104322](讲稿.assets/image-20201026164104322.png)

从上面的例子，都是基于浏览器来实现的，但刚开始介绍token的时候也说了，token是跨平台的，除了能支撑浏览器场景，也可以支撑app的场景。



看一下授权服务的工作过程：

分两个环节：

1、颁发授权码--间接流程

2、颁发访问令牌--直接流程

![image-20201026172746870](讲稿.assets/image-20201026172746870.png)



看一下优特云授权服务颁发的令牌：

```json
{
    "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX25hbWUiOiI0Nzc0OTk5MjYzNjQwMzEzODcwIiwic2NvcGUiOlsicmVhZCJdLCJleHAiOjE2MDYzNzQ5MTQsImFjY291bnRTeXN0ZW1LZXkiOiJkZWZhdCIsImp0aSI6IjU3ZTk0N2M0LTE0ZWUtNGNmMi05NzU4LWUxZjFlNmEzODQ5MiIsImNsaWVudF9pZCI6InNzby1nYXRld2F5IiwidXNlcm5hbWUiOiJzaGluZG8ifQ.4gQw3Fgxbmksz0DLHFvmo3fY1efFf0vX3zIHWREk4_k",
    "token_type": "bearer",
    "refresh_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX25hbWUiOiI0Nzc0OTk5MjYzNjQwMzEzODcwIiwic2NvcGUiOlsicmVhZCJdLCJhdGkiOiI1N2U5NDdjNC0xNGVlLTRjZjItOTc1OC1lMWYxZTZhMzg0OTIiLCJleHAiOjE2MDYzNzQ5MTQsImFjY291bnRTeXN0ZW1LZXkiOiJkZWZhdCIsImp0aSI6ImNjNDMxN2Y5LWI0ZmEtNGU4ZS1hY2JkLTE3ODY0MjVlYWY1MiIsImNsaWVudF9pZCI6InNzby1nYXRld2F5IiwidXNlcm5hbWUiOiJzaGluZG8ifQ.Ug3NKw9hyMyu9izODrgzgpEgU9_Cx_7R5ulDt_6oh0g",
    "expires_in": 2591999,
    "scope": "read",
    "accountSystemKey": "defat",
    "username": "shindo",
    "jti": "57e947c4-14ee-4cf2-9758-e1f1e6a38492"
}
```

![image-20201027151655514](讲稿.assets/image-20201027151655514.png)

可以看到oauth服务在发放access_token的同时，还会下发refresh_token：刷新令牌。

有什么用？为什么要和access_token一起发？

作用：防止第三方的高频登陆，主要是出于用户体验的考虑。就好比你在京东/淘宝一样，是不是只要你登陆了一次，就好久不需要你登陆了。

为什么一起发：如果access_token失效了，又没有刷新令牌，那还是要用户手动授权。

怎么用：

![image-20201027152334539](讲稿.assets/image-20201027152334539.png)



使用jwt结构化令牌信息，增强拓展性 

[jwt](..\OAuth2.0\04-OAuth2.0使用JWT结构化令牌.md)     (CTRL+单击打开)

jwt令牌有什么优势，为什么会出现？

先理解一个概念：**令牌内检**



![image-20201027162627949](讲稿.assets/image-20201027162627949.png)



![image-20201027162840614](讲稿.assets/image-20201027162840614.png)

![image-20201027164322655](讲稿.assets/image-20201027164322655.png)





> 杨波 . ACME公司的微服务架构图

![img](讲稿.assets/228199yya6051f1f62f23547a88be4ff.jpg)

优点：

1、高性能

2、增强系统的可用性和可伸缩性，可以自定义token结构

缺点：

1、无状态，基于上面的设计，授权服务器是不会存jwt token的，这就带来一个问题：要想改变已经发放出去的令牌状态，做不到。就好比，你要用户修改密码后，旧令牌失效，不好意思，不可以。令牌在没有过期之前，都是有效的。



参观一下市面上主流厂商都是怎么玩oauth的：

oauth的实际应用--openID--微信、七牛、极光

微信-授权码许可模式：

oauth2-service   --   SocialController   --  customOauthService.getAuthorizationUrl(appKey, redirectUrl)  --  

```java
private static final String AUTHORIZE_URL = "https://open.weixin.qq.com/connect/qrconnect?appid=%s&redirect_uri=%s&response_type=code&state=esfadsgsad34fwdef&scope=snsapi_login#wechat_redirect";

private static final String ACCESS_TOKEN_URL = "https://api.weixin.qq.com/sns/oauth2/access_token?grant_type=authorization_code";
```



七牛： （同一账户下 所有命名空间的app_id和app_secret一样）

![image-20201027172515983](讲稿.assets/image-20201027172515983.png)

```java
//QiniuConfigService.java
Auth auth = Auth.create(qiniuConfigEntity.getAccessKey(), qiniuConfigEntity.getSecretKey());

//token有效期默认是3600s
upToken = auth.uploadToken(qiniuConfigEntity.getBucketName(), fileName);

Response response = uploadManager.put(file.getInputStream(), key, upToken, null, null);

// UploadManager.class:
StreamUploader uploader = new StreamUploader(this.client, token, key, stream, params, mime, this.configuration);
 return uploader.upload();

//StreamUploader.class:
public Response upload() throws QiniuException {....}

private Response upload0() throws QiniuException {
    
    ...
        
    // L134
    response = this.makeBlock(this.blockBuffer, bufferIndex);
    
    ....
        
}

private Response makeBlock(byte[] block, int blockSize) throws QiniuException {...}

//把token 塞 header里面
private Response post(String url, byte[] data, int offset, int size) throws QiniuException {
    return this.client.post(url, data, offset, size, (new StringMap()).put("Authorization", "UpToken " + this.upToken), "application/octet-stream");
}

```



极光短信：（同一账户下 以应用为单位，不同应用的app_id和app_secret都不一样）

![image-20201027172424802](讲稿.assets/image-20201027172424802.png)

```java
/sendVerifyCode
    
 //发送验证码
SmsServiceConfigEntity smsConfig = getSmsConfig(appPrefix);
JpushSMSResponseBo jpushResponseBo = jpushSMSService.sendCode(
    smsConfig.getAppKey(), smsConfig.getAppSecret(), mobile, template);

String basicAuth = "Basic " + new String(Base64.encode(generateAuthString(appKey, secrect).getBytes()));
requestProperties.put("Authorization", basicAuth);
String result = WebCommonUtils.doPost(urlString, sumbitContent,3000, 3000, requestProperties);
```



oauth的其他授权模式

1、资源拥有者凭证许可 ： 优特云

顾名思义：资源拥有者的凭证就是用户的凭证，就是用户名和密码。

从安全性来讲，肯定是oauth4种模式中相对较低的，那为什么oauth还要提供这种模式？

还是上面的例子，打单软件如果就是京东官方自己捣腾的一款软件，小明也是京东的用户，那么小明完全可以使用用户名密码来直接使用打单软件的。这样一来，打单软件的身份就不是“第三方”了。

但是如果每次打单软件都是拿着小明用户名和密码去调用京东开放平台的API，明显增加了用户名和密码等敏感信息暴露的风险。

所以oauth就设计了这种模式，打单软件只需要第一次用户名和密码去换回一个token，后续都通过这个token来访问京东开放平台就可以了。

看一下这个模式具体的流程：

![image-20201028233112245](讲稿.assets/image-20201028233112245.png)

这种方式是不是有种似曾相识的感觉？  (这里可展开：怎么访问商业云的接口的？)

 **grant_type 的值为 password**，告诉授权服务使用资源拥有者凭据许可的方式去请求访问



2、客户端凭证许可：七牛

资源没有很明确的拥有者概念。怎么理解？

比如说，智厨的‘“优大厨”这款软件，它里面的菜谱是不是要有很多介绍的详情图或者小视频，那么这些图片或者视频资源，它们就不归属于指定的用户了，而是属于“优大厨”这款软件的。换一种说法：“优大厨”就是资源拥有者。

这种场景下的授权，就是客户端凭证授权，可以直接使用注册时生成deapp_id和app_secret来换取访问的access_token

![image-20201028235011779](讲稿.assets/image-20201028235011779.png)



 **grant_type 的值为 client_credentials**，告诉授权服务要使用第三方软件凭据的方式去请求访问



3、隐式许可

相当与授权码模式中的打单软件没有了后端服务，只有一个前端，但是又要搞oauth2的机制，怎么玩，直接在前端的js代码里面直接实现。

既然在浏览器上实现，就没有任何保密数据可以隐藏了，也就不在需要应用密钥app_secret了，也不需要通过授权码code来获取access_token了。为什么，想想之前加授权码的原因就明白了。

![image-20201029000711464](讲稿.assets/image-20201029000711464.png)



response_type 的值变成了 **token**，想想之前授权码许可模式的response_type是什么  ？

code



各个模式的对比：



![img](讲稿.assets/3ee0ceff6c543157a51aae985756454d.jpg)

security 怎么校验jwt token 是否过期？

