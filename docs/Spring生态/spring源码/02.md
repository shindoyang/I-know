AbstractApplicationContext.class

refresh()

prepareRefresh() --> 设置启动时间、关闭状态false、激活状态true、获取环境变量（propertySourceList  使用的是 CopyOnWriteArrayList数据类型   方法都加了ReentrantLock锁，since JDK1.5）、earlyApplicationEvents 使用的是 LinkedHashSet数据类型

任务：明确了解各个数据集合类型的作用



查询下JDK各个版本之间的变化

从现在来看，感觉JDK1.5的进步好大



1、首先创建Bean工厂

**一定要看注释**

看DefaultListableBeanFactory的类图，使用最多的一个类

注意：

* HierarchicalBeanFactory  继承，父子容器。AbstractBeanFactory.doGetBean() --> getParentBeanFactory();
* ListableBeanFactory：枚举bean实例
* ConfigurableBeanFactory

2、设置工厂的具体参数

**loadBeanDefinitions(factory)**  特别复杂，重载方法特别多，do方法才是真正干活的

configLocations  ，xml的时候set进去的值



3、加载xml

注意栈里面refreshBeanFactory的两个属性：beanDefinitionMap，beanDefinitionNames ，当xml配置文件的bean配置被解析后，后存放到这里

RootBeanDefinition ，GenericBeanDefinition  涉及BeanDefinition合并



prepareRefresh（）

注释：前戏，做容器刷新前的准备工作

* 设置容器的启动时间
* 设置活跃状态为true
* 设置关闭状态为false
* 获取Environment对象，并加载当前系统的属性值到Environment对象中。
* 准备监听器和事件的集合对象，默认为空的集合



configurableListableBeanFactory beanFactory= obtainFreshBeanFactory();

注释：

* 创建容器对象：DefaultLlistableBeanFactory
* 加载xml配置文件的属性值到当前工厂中，最重要的是BeanDefinition



4、初始化BeanFactory，或者给bean工厂设置具体的属性值

spring EL



好好看下，了解其作用：

ignoreDependencyTypes

ignoreDependencyInterface

忽略接口的实现



5、增强器

postProcessBeanFactory(beanFactory) 模板方法，当前类实现



6、执行BFPP，修改bean定义信息



7、

实例化之前，也要做前戏，lisener，观察者模式





























