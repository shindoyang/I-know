### 变量(四)

在设置了"取处理程序"的情况下，Nginx变量也可以选择将其值容器用作缓存，这样在多次读取变量的时候，就只需要调用“取处理程序”计算一次。我们下面就来看一个这样的例子：

```nginx
map $args $foo{
    default 0;
    debug   1;
}

server {
    listen 8080;
    location /test{
        set $orig_foo  $foo;
        set $args debug;
        
        echo "original foo: $orig_foo";
        echo "foo: $foo";
    }
}
```

这里首次用到了标准**ngx_map**模块的**map**配置指令，我们有必要在此介绍一下。map在英文中除了“地图”之外，也有“映射”的意思。比方说，中学数学里讲的“函数”就是一种“映射”。而Nginx的这个**map**指令就可以用于定义两个Nginx变量之间的映射关系，或者说是函数关系。回到上面这个例子，我们用**map**指令定义了用户变量$foo与$args内建变量之间的映射关系。特别地，用数学上的函数记法 y = f(x) 来说，我们的$args就是"自变量"x，而$foo 则是“因变量”y ，即$foo 的值是有$args 的值来决定的，或者按照书写顺序可以说，我们将$args变量的值映射到了$foo变量上。

现在我们再来看**map**指令定义的映射规则：

```nginx
map $args $foo{
    default  0;
    debug    1;
}
```

花括号中第一行的default是一个特殊的匹配条件，即当其他条件都不匹配的时候，这个条件才匹配。当这个默认条件匹配时，就把“因变量”$foo映射到值0。而花括号中第二行的意思是说，如果“自变量”$args精确匹配了debug这个字符串，则把“因变量”$foo映射到值1。将这两行合起来，我们就得到如下完整的映射规则：当**$args**的值等于debug的时候，$foo变量的值就是1，否则$foo的值就为0。

明白了**map**指令的含义，再来看location /test。在这里，我们先把当前$foo变量的值保存在另一个用户变量$orig_foo中，然后再强行把**$args**的值改写为debug，最后我们在用**echo**指令分别输出$orig_foo 和$foo 的值。

从逻辑上看，似乎当我们强行改写**$args**的值为debug之后，根据先前的**map**映射规则，$foo变量此时的值应当自动调整为字符串1，而不论$foo原先的值是怎样的。然而测试结果并非如此：

```shell
$ curl 'http://8080/test'
original_foo: 0
foo: 0
```

第一行输出指示$orig_foo的值为0，这正是我们期望的：上面这个请求并没有提供URL参数串，于是**$args**最初的取值就是空，再根据我们先前定义的映射规则，$foo变量在第一次被读取时的值就应当是0（即匹配默认的那个default条件）。

