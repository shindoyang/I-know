2021-04-09

1、jwt自动刷新，可以参考：https://www.cnblogs.com/powerwu/articles/11214273.html
2、bio和nio的区别
3、分库分表的原则
4、全局异常怎么处理（一个异常两个格式，怎么兼顾内部接口调用和外部响应）
5、synchronized锁的对象是static和方法的时候有什么区别（锁的力度不一样，static锁的是.class，所以是强阻塞的）

6、队列的发布订阅模式和队列模式的区别

7、如果是发布订阅模式的话，同一类型的消费者出现多个实例，怎么保证消息的不重复消费？（说白了重复消费就是要考虑接口调用的幂等性：用redis和缓存唯一键，或者利用mysql的主键唯一特性。参考：https://www.cnblogs.com/qingmuchuanqi48/p/11124068.html）

8、分布式主键Id，怎么保证超高并发（提前生成一批，类似于漏桶和令牌桶的原理）

9、zookeeper的paxos 协议

10、mysql的集群模式？在读写分离的情况下，怎么实现业务对读写切换的无感？（使用aop切面代理dataSource）



### 怎么保证消息队列消费的幂等性？

 

其实还是得结合业务来思考，我这里给几个思路：

 （1）比如你拿个数据要写库，你先根据主键查一下，如果这数据都有了，你就别插入了，update一下好吧

 （2）比如你是写redis，那没问题了，反正每次都是set，天然幂等性

 （3）比如你不是上面两个场景，那做的稍微复杂一点，你需要让生产者发送每条数据的时候，里面加一个全局唯一的id，类似订单id之类的东西，然后你这里消费到了之后，先根据这个id去比如redis里查一下，之前消费过吗？如果没有消费过，你就处理，然后这个id写redis。如果消费过了，那你就别处理了，保证别重复处理相同的消息即可。

 