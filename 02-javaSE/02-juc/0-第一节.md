![canvas](C:/Users/yanggeng/Desktop/canvas.png)

TODO：补纤程的概念 （2021-02-19）

### 什么是线程

#### 基本概念

 <img src="images/image-20210219143823470.png" alt="image-20210219143823470" style="zoom: 80%;" />

* 进程 线程 协程/纤程(quasar)
* program app -> QQ.exe
* QQ running ->进程
* QQ running ->进程
* 线程 -> 一个进程里面的不同的执行路径
* 纤程 -> CPU-Ring0-12-Ring3
  - Ring0 -> 内核态Ring3 ->用户态
  - 内核调用/系统调用-纤程的操作
  - 用户态启动线程
    * 进入到内核态-保护用户态的线程
    * 用户态不经过内核态的线程-纤程golang的go程
* 用户态-内核态
  - int 0x80-128
  - sysenter cpu支持
  - 保存用户态现场
    * 寄存器压栈
    * 进行syscall
    * 内核态返回eax
    * 恢复用户态现场
    * 用户程序继续执行

--
T1 extends Thread{重写run()}

* new T1().run(); 这种方式是方法调用：是一条线程内顺序执行；
* new T1().start(); 两条路同时进行
**线程：一个程序里不同的执行路径**

#### 创建线程的2种方式

* 继承Thread类

```java
class T1() extends Thread{
    @Override
    public void run(){sout("hello T1")}
}

psvm{
    new T1().start();
}
```



* 实现Runnable接口

```java
class T2() implements Runnable{
    @Override
    public void run(){sout("hello T2")}
}

psvm{
    new Thread(new T2()).start();
}

```

或者lambda表达式

```java
new Thread(()->{ sout("hello lambda!") }).start();
```

**面试题：**创建线程的三种方式：1、Thread 2、Runnable 3：线程池 Executors.newCachedThread(其实也是用前两种之一)

### 线程状态

* sleep 睡眠，时间结束后自动复活，也是回到就绪状态
* yield 暂停一会（让出一下cpu），进入等待队列里（就绪状态），极少使用场景，压测有可能。
* join 加入，要等加入的线程执行完后才回到当前线程执行。可以用来等待另外一个线程结束。
  * 解决线程调用顺序问题：t1/t2/t3,如何保证先执行完t3，再执行t2，最后才执行t1。可以t1里面调t2.join，t2里面调t3.join。
  * 谁join谁有影响的

-- 知识边缘导致学得越多，不懂的也越多

#### 获取线程状态  JVM管理

Thread.getState();

 ![image-20210219144920025](images/image-20210219144920025.png)

* 线程调度器执行：交给操作系统执行
* 线程调度器执行的整个状态叫：Runnable ，里面细分两个状态：Ready(就绪状态) 和 Running（确实在运行的状态）
* Ready-就绪状态：在cpu的等待队列里面排队等着
* Running-运行状态：从等待队列里面进入cpu里面执行
* 线程Teminated之后不可能再start
* stop状态已经被弃用，不建议使用
* interrupt：打断，要catch异常处理

